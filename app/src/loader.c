#include <stdint.h>

#include <kernel.h>
#include <sys/printk.h>

#include "pic.h"

// Generated by linker, delimits PIC ELF binary
extern uint32_t *_picapps;
extern uint32_t *_epicapps;

static uint32_t app_sram[512];

/*
 * Loader for main (PIC) application
 * Derived from github.com/lab11/pic-explorations and github.com/tock/libtock-c
 */
void main(void)
{
    printk("\nRunning PIC Loader (_picapps: %p, _epicapps: %p)\n", &_picapps, &_epicapps);

    // The section where we use everything once to include it
    // TODO: get rid of this garbage
    k_sleep(0);
    
    struct k_timer t_unused;
    k_timer_init(&t_unused, NULL, NULL);
    k_timer_start(&t_unused, 1000, 1000);
    k_timer_stop(&t_unused);

    struct pic_hdr *hdr = (struct pic_hdr *)&_picapps;

    uint32_t *flash_location = (uint32_t *)&_picapps;

    // Dynamic allocation
    // requires enabling CONFIG_HEAP_MEM_POOL_SIZE in v2m_musca_nonsecure_defconfig
    // uint32_t *sram_location = (uint32_t *) k_malloc(hdr->data_size + hdr->bss_size);
    
    // Static allocation
    uint32_t *sram_location = (uint32_t *) app_sram;

    if (!sram_location) { // Error allocating data for app
        printk("Error allocating data memory\n");
        return;
    }

    // Copy .data section into SRAM
    //printk("    copying .data...\n");
    uint32_t *data_src = (uint32_t *) (hdr->data_sym_start + (uint32_t)flash_location);
    uint32_t *data_dst = sram_location;
    for (int i = 0; i < (hdr->data_size / sizeof(uint32_t)); i++) {
        *data_dst++ = *data_src++; 
    }

    // Zero out .bss
    //printk("    copying .bss...\n");
    uint32_t *bss_start = (uint32_t *)((uint32_t)sram_location + hdr->bss_start);
    for (int i = 0; i < (hdr->bss_size / sizeof(uint32_t)); i++) {
        *bss_start++ = 0;
    }

    //printk("    processing relocations...\n");
    uint32_t *rel_start = (uint32_t *)(hdr->rel_start + (uint32_t)flash_location);
    // Each relocation entry consists of a pair of 4-byte values
    for (int i = 0; i < (hdr->rel_size / sizeof(uint32_t)) / 2; i++, rel_start+=2) {
        uint32_t offset = *rel_start;
        uint32_t info = *(rel_start + 1);

        if (!info) { // R_ARM_NONE relocation, ignore
            continue;
        }
        
        if (info != 0x17) { // Unsupported relocation, ignore
            continue;
        } 

        // Apply .got relocation. Relocations are given offsets assuming that
        // the GOT is placed at 0x0. Any offset into flash lies above
        // PIC_FLASH_LINK_BASE, the arbitrary location defined in the PIC
        // linker script. The current pic.ld places flash at 0x10000000.
        uint32_t *target = 0x0;
        if (offset >= PIC_FLASH_LINK_BASE) { // resolve relative to code RAM
            target = (uint32_t *)((offset - PIC_FLASH_LINK_BASE) + (uint32_t)flash_location);
        } else { // resolve relative to data RAM
            target = (uint32_t *)((uint32_t)sram_location + offset);
        }

        // Repair value at location pointed to by relocation offset
        uint32_t fixed_val = 0;
        if (*target >= PIC_FLASH_LINK_BASE) {
            fixed_val = (*target - PIC_FLASH_LINK_BASE) + (uint32_t)flash_location;
        } else {
            fixed_val = *target + (uint32_t)sram_location;
        }
        printk("--Relocating value at %p from %x -> %x\n", target, *target, fixed_val);
        *target = fixed_val;
    }

    //printk("    setting GOT base register...\n");
    // Context Switch:
    // Set base register (r9) to the beginning of GOT, at the start of data SRAM
    printk("--Setting PIC register (r9) to %x\n", (uint32_t)sram_location);
    __asm("ldr   r9, %0" :: "m" ((uint32_t)sram_location));

    // Update entry location and jump into application
    uint32_t jmp = (hdr->entry - PIC_FLASH_LINK_BASE) + (uint32_t)flash_location;    
    //printk("    jumping to PIC main() at %x...\n", jmp);
    void (*pic_main)(void) = (void (*)(void))(jmp | 1); // Stay in thumb mode

    printk("\n**** App Main ****\n\n");
    pic_main();
}

